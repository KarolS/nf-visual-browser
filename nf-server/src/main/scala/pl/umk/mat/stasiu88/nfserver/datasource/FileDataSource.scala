/*
 * Copyright (c) 2011,2012 Karol M.Stasiak <karol.m.stasiak@gmail.com>
 * This software is licensed under European Union Public Licence v.1.1 or later
 */

package pl.umk.mat.stasiu88.nfserver.datasource

import java.io.File

import scala.collection.breakOut

import pl.umk.mat.stasiu88.nfserver.input.DataFile
import pl.umk.mat.stasiu88.nfserver.query.QueryModel._
import pl.umk.mat.stasiu88.nfserver.query._
import pl.umk.mat.stasiu88.nfserver.worker.Result
import pl.umk.mat.stasiu88.nfserver.Flow
import scalaz._
import Scalaz._

/**
 * Data source based on a single file generated by nfcapd.
 * <br>
 * Źródło danych oparte o pojedynczy plik wygenerowany przez nfcapd.
 */
class FileDataSource(val file: File) extends DataSource{
  val filename = file.getAbsolutePath()
  def this(fileName: String) = this(new File(fileName))
  
  @volatile
  private[this]var vfirstSeen = Long.MinValue
  @volatile
  private[this]var vlastSeen = Long.MaxValue
  
  try {
    val tmp = FileRangeCache.get(filename)
    vfirstSeen=tmp._1
    vlastSeen = tmp._2
  } catch {
    case _=> //IGNORE IT!
  }
  
  @volatile
  private[this]var read = false
  @volatile
  private[this]var assumeValid = true
  
  def firstSeen = vfirstSeen
  def lastSeen = vlastSeen
  
  private def readHeader[A](q:Query)(block: Option[DataFile]=>Option[A]):Option[A] = {
    val optData = 
      if(assumeValid && q.timeWindow.overlapsWith(firstSeen,lastSeen)){
        synchronized {
          var data:DataFile = null
          try{
            data = new DataFile(filename)
            val vfirstSeen = data.firstSeen
            val vlastSeen = data.lastSeen
            FileRangeCache.update(filename, firstSeen, lastSeen)
            read = true
            Some(data)
          }catch{
            case e:Exception =>
              e.printStackTrace()
              assumeValid = false
              if(data ne null) data.close
              None
          }
        }
      }else None
    try{
      block(optData)
    } catch {
      case e:Exception =>
        e.printStackTrace()
        None
    } finally {
      optData.foreach(_.close)
    }
  }
  
  val allacceptingFilters = Set[SplitFilter](
      LeafSplitFilter(AllFilter),
      NodeSplitFilter(AllFilter,List(LeafSplitFilter(AllFilter)))
      )
  
  //TODO: check if optimal
  override def getQuickResult(q:Query):Option[Result]={
    //TODO: optimize for pure TCP/UDP/ICMP queries
    readHeader(q) {
      case None => return None
      case Some(data) =>
      if(!assumeValid) return None
      if(!q.timeWindow.contains(firstSeen,lastSeen)) return None
      if(!allacceptingFilters.contains(q.splitfilter)) return None
      if(q.statistic.backupPeriod /== EachAlways) return None
      if(q.statistic.indexing /== NilIndex) return None
      q.statistic.sumOver foreach{ 
        case Bytes => ()
        case Packets => ()
        case Flows => ()
        case _ => return None
      }
      val flows = data.flowCount
      val bytes = data.byteCount
      val packets = data.packetCount
      some(new Result(Vector(q.statistic.sumOver.map{
        case Bytes => Map(0L->Map(List[Int]()->bytes))
        case Packets => Map(0L->Map(List[Int]()->packets))
        case Flows => Map(0L->Map(List[Int]()->flows))
        case _ => return None
      }:_*), 1, q.statistic.sumOver.length))
    }
  }
  
  def foreach(q: Query)(f: Flow=>Unit){
    readHeader(q) { 
      case None => None
      case Some(data) => 
      if(assumeValid && q.timeWindow.overlapsWith(firstSeen,lastSeen)){
        data foreach f
      }
      None
    }
    ()
  }
}
